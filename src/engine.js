
// engine.js - core signal building logic (exported)
export function tickValueFor(market){ if(market==='ES') return 12.5; if(market==='MES') return 1.25; if(market==='NQ') return 20; if(market==='MNQ') return 0.5; return 1; }
function round2(x){ return Math.round(x*100)/100; }
function findWalls(rows){ if(!rows || rows.length===0) return null; const calls = rows.filter(r=>r.type==='Call'); const puts = rows.filter(r=>r.type==='Put'); const callOiMax = calls.reduce((a,b)=>a==null||b.oi>a.oi?b:a,null); const putOiMax = puts.reduce((a,b)=>a==null||b.oi>a.oi?b:a,null); return {callOiMax,putOiMax}; }
function determineBias(price,vah,val,poc,gex){ const trend = price>vah ? 'bull' : price<val ? 'bear' : 'neutral'; let bias = null; if(trend==='bull' && gex!=='negativ') bias='long'; if(trend==='bear' && gex!=='positiv') bias='short'; if(!bias) bias = price>poc ? 'long' : price<poc ? 'short' : 'neutral'; return {trend,bias}; }
export function buildSignal(form, rows){ const market = form.market.value; const price = parseFloat(form.price.value); const date = form.date.value||''; const crvTarget = parseFloat(form.crvTarget.value); const risk = parseFloat(form.risk.value); const tick = tickValueFor(market); const isCrypto = ['BTC','DOGE','SOL','SHIB','XRP'].includes(market); let vah,val,poc,vhigh,vlow,maxPain,gex,atr,vix; if(!isCrypto){ vah=parseFloat(form.vah.value); val=parseFloat(form.val.value); poc=parseFloat(form.poc.value); vhigh=parseFloat(form.vhigh.value); vlow=parseFloat(form.vlow.value); maxPain=parseFloat(form.maxPain.value); gex=form.gex.value; atr=parseFloat(form.atr.value); vix=parseFloat(form.vix.value); } else { vhigh=parseFloat(form.vhighC.value); vlow=parseFloat(form.vlowC.value); vah=parseFloat(form.vahC.value); poc=parseFloat(form.pocC.value); val=parseFloat(form.valC.value); atr=parseFloat(form.atrC.value); maxPain=null; gex='neutral'; vix=null; } const walls=findWalls(rows); const callWall=walls&&walls.callOiMax?walls.callOiMax.strike:null; const putWall=walls&&walls.putOiMax?walls.putOiMax.strike:null; const biasObj=determineBias(price,vah,val,poc,gex); const trend=biasObj.trend; const bias=biasObj.bias; function near(a,b,th=5){ return a!=null && b!=null && Math.abs(a-b) <= th; } let confluence=null; if(near(callWall,poc)) confluence={type:'call_poc',level:callWall}; if(near(putWall,poc)) confluence={type:'put_poc',level:putWall}; if(!confluence){ if(near(callWall,vah)) confluence={type:'call_vah',level:callWall}; if(near(putWall,val)) confluence={type:'put_val',level:putWall}; } let direction=null,entry=null,stop=null,tp1=null,tp2=null,tp3=null,reason=[]; if(confluence){ if(confluence.type.startsWith('put')){ if(price>confluence.level){ direction='Short'; entry=confluence.level; stop=Math.max((vhigh||price)+1, entry + Math.max(8, (atr||20)*0.2)); tp1 = poc ? Math.min(poc, entry - Math.max(10, (atr||20)*0.25)) : entry - 20; tp2 = (val && tp1>val) ? val : entry - Math.max(20, (atr||20)*0.5); tp3 = tp2 - Math.max(20, (atr||20)*0.7); reason.push('Put-Wall confluence at ' + entry); } } else if(confluence.type.startsWith('call')){ if(price<confluence.level){ direction='Long'; entry=confluence.level; stop=Math.min((vlow||price)-1, entry - Math.max(8, (atr||20)*0.2)); tp1 = poc ? Math.max(poc, entry + Math.max(10, (atr||20)*0.25)) : entry + 20; tp2 = (vah && tp1<vah) ? vah : entry + Math.max(20, (atr||20)*0.5); tp3 = tp2 + Math.max(20, (atr||20)*0.7); reason.push('Call-Wall confluence at ' + entry); } } } else { if(bias==='long' && price<poc){ direction='Long'; entry=Math.max(price+0.2,poc-0.5); stop=price-Math.max(8,(atr||20)*0.2); tp1=poc+Math.max(8,(atr||20)*0.2); reason.push('Bias long vs POC'); } if(bias==='short' && price>poc){ direction='Short'; entry=Math.min(price-0.2,poc+0.5); stop=price+Math.max(8,(atr||20)*0.2); tp1=poc-Math.max(8,(atr||20)*0.2); reason.push('Bias short vs POC'); } } if(!direction) return {ok:false,msg:'Kein gültiges Setup (keine Konfluenz oder kein passender Bias).',debug:{walls}}; if(direction==='Short' && vhigh && entry>vhigh) return {ok:false,msg:'Short-Entry verletzt Regel: keine Short-Entrys über dem Vortageshoch (kein A++).',debug:{entry,vhigh}}; if(direction==='Long' && vlow && entry<vlow) return {ok:false,msg:'Long-Entry verletzt Regel: keine Long-Entrys unter dem Vortagestief (kein A++).',debug:{entry,vlow}}; if(!tp1) tp1 = direction==='Long' ? entry + 15 : entry - 15; if(!stop) stop = direction==='Long' ? entry - Math.max(8,(atr||20)*0.2) : entry + Math.max(8,(atr||20)*0.2); const riskPoints = Math.abs(stop - entry); const rewardPoints = Math.abs(tp1 - entry); const crv = riskPoints>0 ? round2(rewardPoints / riskPoints) : null; if(!crv || crv < 1) return {ok:false,msg:`CRV zu TP1 zu klein (${crv} :1) — kein profitables Setup.`,debug:{crv}}; if(crv < crvTarget) return {ok:false,msg:`Gefundenes CRV ${crv}:1 < gewünschtem CRV ${crvTarget}:1 — kein Signal.`,debug:{crv,crvTarget}}; const riskDollars = risk; const contracts = Math.max(1, Math.floor(riskDollars / (riskPoints * tick))); let prob = 0.6; if(crv >= 3) prob = 0.8; else if(crv >= 2) prob = 0.7; if(confluence && crv>=3) prob += 0.05; const probability = Math.min(0.95, prob); let rating='A'; if(crv>=3 && confluence && ((trend==='bull' && direction==='Long') || (trend==='bear' && direction==='Short'))) rating='A++'; else if(crv>=2 && confluence) rating='A+'; let orderType = 'Limit'; if(direction==='Long' && entry > price) orderType = 'Buy Stop'; if(direction==='Short' && entry < price) orderType = 'Sell Stop'; if(direction==='Long' && entry <= price) orderType = 'Limit Buy'; if(direction==='Short' && entry >= price) orderType = 'Limit Sell'; return { ok:true, market, date, direction, entry:round2(entry), stop:round2(stop), tp1:round2(tp1), tp2:round2(tp2), tp3:round2(tp3), crv, contracts, rating, probability:Math.round(probability*100)+'%', orderType, reason, debug:{walls} }; function round2(x){ return Math.round(x*100)/100; }
